{
id: "standard_values",

# rationale for this file:
#  Multiple basic prototypes use these values, and previously redundantly had them as literal constants.
#  Objects based on prototypes can't refer to the properties in said prototype if they redeclare them - they frequently do to put that value in a conditional, and they have to redeclare it as yet another redundant copy of this constant.

#  certain functions are truly global, but need the convenience of being properties for easy access to the referring object's scope
properties: {

#-------------------------- global values --------------------------#
	standard_thrown_damage: "int :: 50",
	kill_anything:  "int :: 20000",		#a large int meant to be fatal to anything
	
	lower_difficulty: "bool :: level.player.difficulty < difficulties.challenging",
	higher_difficulty: "bool :: level.player.difficulty > difficulties.casual",

	max_recursion_depth: "int|decimal :: 1000",  #incorrect behavior is better than stack overflows, which we'd occasionally get if FFL is allowed to recurse indefinitely.  This has to manually be checked against a counter value.

	difficulties: "{casual: int, challenging: int, unfair: int} :: {casual: 0, challenging: 1, unfair: 2}",


		#all objects are possible to stand on top of, so we need these springiness values to be global:
	springiness: "int :: 0",
	spring_amount: "int :: 0",
	bounce_roundness: "int :: 0",


#-------------------------- custom storage --------------------------#

		//this is our one built-in "pressure-release valve" to escape typechecking in cases where it's grossly inconvenient.
		// it's meant for the console, and is also used in a few rare, rare cases such as being used by the player object for stuff like event storage, but only for when it needs a non-integer type.  Don't ever use this unless you really need it (i.e. you need to store arrays of stuff, etc), because skipping around type checking opens a pandora's box of bugs.
	custom_storage: { type: "{string -> any}", default: {} },
	cs: "custom_storage",



#-------------------------- general functions --------------------------#
	speed: "decimal :: abs(hypot(velocity_x, velocity_y))",  //speed in the dimensionless, polar-coordinate sense.

	set_max_hitpoints: "def( {casual: int, challenging: int} max_value_for_ ) -> commands
						if(lower_difficulty, [set(max_hitpoints, max_value_for_.casual),set(hitpoints, max_value_for_.casual)], [set(max_hitpoints, max_value_for_.challenging),set(hitpoints, max_value_for_.challenging)] )",

	#late-bound execution of commands across level-boundaries
	eval_and_exec: "def(string f) -> commands [set(event_handlers.__do_stuff_eval_and_exec, f), fire_event('__do_stuff_eval_and_exec')]",


	on_same_screen_as: "def(custom_obj obj1, custom_obj obj2) -> bool
					abs(obj1.mid_x - obj2.mid_x) < level.camera_position[2]/2 and
					abs(obj1.mid_y - obj2.mid_y) < level.camera_position[3]/2 and
					bool(obj2.alpha) and true or false",

	can_see: "def(custom_obj obj1, custom_obj obj2) -> bool on_same_screen_as(obj1, obj2) and lib.math.clear_line_of_sight_between(level, obj1, obj2).clear",

	do_until_count: "def(int total, string counter_name, {on_loop: commands, on_exit: commands} args) -> commands
						execute(me, if(me[counter_name] < total, [add(me[counter_name], 1), args.on_loop], [set(me[counter_name],0), args.on_exit]))",

	do_unless_on_cooldown: "def(int cooldown_duration, string counter_name, {on_ready: commands, otherwise: commands} args) -> commands
								execute(me, if(cooldown_duration < (level.cycle - (int <- me[counter_name])), [args.on_ready, set(me[counter_name], level.cycle)], args.otherwise))",

#-------------------------- turning functions --------------------------#
	turn_towards_player: "commands :: if(not is_facing_towards_player, turn_around)",
	turn_around: "commands :: set(facing,-facing)", //this is *basically* virtual in all usage, but sensible behavior here doesn't hurt
	direction_towards_player: "int :: if(midpoint_x - level.player.midpoint_x > 0, -1, 1)",
	is_facing_towards_player: "bool :: facing = if(level.player.midpoint_x < self.midpoint_x, -1, 1)",
	
	
	attempt_animation: "def(string anim_name, string fallback_anim) -> commands execute(me, if(anim_name in available_animations, set(animation, anim_name), set(animation, fallback_anim)))",

#-------------------------- sound functions --------------------------#
	sound_falloff: "def(string sound_name, int falloff_dist=200, int|decimal max_volume=1.0)  -> commands ((sound(sound_name, volume, fade_in_time, stereo_pan)
						where fade_in_time = 0.0,
						where stereo_pan = [lib.math.constrain(volume, falloff_dist/dist_to_player(-ear_radius), 1.0),lib.math.constrain(0, falloff_dist/dist_to_player(ear_radius), 1.0)]
					) where volume = lib.math.constrain(0, decimal(falloff_dist)/dist_to_player(0), max_volume)
				) where dist_to_player = def(decimal x_offset) -> decimal lib.math.length(self.mid_x, self.mid_y, level.player.mid_x + x_offset, level.player.mid_y), where ear_radius = 250",	
	
	sound_attenuated_by_speed: "def(string sound_file, decimal max_speed=1200.0) -> commands
										//the max_speed is baked-in here, but it's fairly well-tuned for the stuff this function gets used on (dropping chunks of stuff)
									sound_falloff(sound_file, 300, lib.math.ease_in_quad( lib.math.constrain(0.0, speed/max_speed, 1.0) ))",
	
	standard_victory_music: "commands :: execute(level.player, [
									sinusoidal_music_volume_transition(50, 90, 90, 0, 1),
									schedule((7*50), sinusoidal_music_volume_transition(500, 0, 90, 0, 1), ),
									schedule(7*50,music('FrogattoDreamAdventure.ogg')),
									sound('musical/FrogattoFanfare.ogg')])",


#-------------------------- cosmetic functions --------------------------#
	facing_adjusted_velocity_angle: "decimal :: if( facing = 1, 
											atan2(velocity_y, velocity_x),
											mod(atan2(facing * velocity_x,velocity_y),180) -90,
										)",

	sinusoidal_transition: "def( {period: decimal, _init_theta: decimal, _length_theta: decimal, addend: decimal, coefficient: decimal, obj:object, aspect:string} p ) -> commands map(range(p.period), schedule(index, set(p.obj[p.aspect], p.addend + p.coefficient*sin(init_theta + (decimal(length_theta)*index)/p.period )  )))
		where init_theta = p._init_theta*90.0, length_theta = p._length_theta*90.0
	", #pass quality as a string.  TODO: compress range bounds for given quality (not everything is 0.0~1.0 like scale)

	
	sinusoidal_scale_transition: "def(decimal period, decimal init_theta, decimal length_theta, decimal addend, decimal coefficient) -> commands map(range(period), schedule(index, set(me.scale, addend + coefficient*sin(init_theta + (decimal(length_theta)*index)/period )  )))",  # we may in fact want to retain these for speed, though

	sinusoidal_music_volume_transition: "def(decimal period, decimal init_theta, decimal length_theta, decimal addend, decimal coefficient) -> commands map(range(period), schedule(index, set(level.music_volume, addend + coefficient*sin(init_theta + (decimal(length_theta)*index)/period )  )))",


#-------------------------- solidity functions --------------------------#
	find_ceiling: "def(int u, int v, int search_length) -> {x:int, y:int} {x: u, y: if(ceiling_height != null, v+ceiling_height, v+search_length)} where ceiling_height = find(range(search_length), solid(level, u, v + value, 1, 1))",

	find_floor: "def(int u, int v, int search_length) -> {x:int, y:int} {x: u, y: if(floor_height != null, v+floor_height, v+search_length)} where floor_height = find(range(search_length), solid(level, u, v + value, 1, 1))",


	_find_floor_standable: "def(int u, int v, object obj) -> [int]|null
	    find_point_object_can_stand_on(level, obj, u, v, 0, 1)",

	floor_level_beneath_character: "def(int u, int v, object obj) -> [int]|null _find_floor_standable(u,v,obj)",

		//this function only exists for one reason - because the built-in check, called "distance_to_cliff", only queries standability created by tiles.  It does not query standability created by objects.  We still use the original check via a 'logical or' because it handles slopes, and the quick-and-dirty check I made for object-standability does not.
	is_there_flat_ground_ahead_of_us: "def(int distance_ahead) -> bool (if(check_ground != null, (check_ground[1] = me.y2), false) or built_in_cliff_check)
						where check_ground = floor_level_beneath_character(me.mid_x + distance_ahead*facing, me.y2, me),
						where built_in_cliff_check = distance_to_cliff > distance_ahead",
},
}
